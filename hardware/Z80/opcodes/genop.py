#!/usr/bin/env python2.5

# Copyright 2008 Djordjevic Nebojsa <djnesh@gmail.com>
#
# This file is part of py-emu.
#
# py-emu is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# py-emu is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with py-emu.  If not, see <http://www.gnu.org/licenses/>.

import os
import sys
import codeop
import warnings

MYDIR = os.path.abspath(os.path.dirname(__file__))

from _opcodes import *

def convert_to_table(out, type_, table):
    print >>out, '%sdef _init_%s(self):' % (IDENT, type_.lower())
    print >>out, '%s""" init tables """' % (IDENT*2)
    tabname = 'self._%s' % type_.lower()
    print >>out, '%s%s = [self._invalid] * 0x100' % (IDENT*2, tabname)
    
    ret = []
    for code, op, ok in table:
        if not ok: continue
        bits = op.split()
        opcode = bits[0].upper()
        if opcode not in CMDS: continue
        if type_ == 'base':
            fnname = 'op_%02X' % code
        else:
            fnname = 'op_%s_%02X' % (type_.upper(), code)
        ret.append('%s%s[0x%02X] = self.%s # %s' % (IDENT*2, tabname, code, fnname, op))
    ret.append('%s%s = tuple(%s)' % (IDENT*2, tabname, tabname))
    if len(ret):
        print >>out, '\n'.join(ret)

def convert_to_py(out, type_, code, op, tstates):
    bits = op.split()
    opcode = bits[0].upper()
    if opcode not in CMDS:
        warnings.warn('uninplemented %s' % opcode)
        return False
    ret = CMDS[opcode](type_, code, op, tstates, [b.replace("'", '1') for b in bits])
    if not len(ret): return False # empty
    
    if type_ == 'base':
        fnname = 'op_%02X' % code
    else:
        fnname = 'op_%s_%02X' % (type_.upper(), code)
    
    # for prefixed ops: min. time used to fetch the prefix (4) must be substracted
    if type_ != 'base':
        tstates = [t - 4 for t in tstates]
    
    src = []
    src.append('%sdef %s(self):' % (IDENT, fnname))
    src.append('%s""" %s """' % (IDENT*2, op))
    src.append('%s%s' % (IDENT*2, (ADD_T % (tstates[0], tstates[0]))))
    src.append('%s# %s' % (IDENT*2, opcode))
    for l in ret:
        src.append('%s%s' % (IDENT*2, l.rstrip()))
    src.append('%s# end' % (IDENT*2))
    src.append('%s' % IDENT)
    
    codeop.compile_command('\n'.join([s[len(IDENT):] for s in src]), opcode.lower()) # check syntax
    print >>out, '\n'.join(src)
    return True

def process_ofile(fname, name, dasm_fh):
    print 'Processing %s (%s)' % (fname, name)
    print '='*72
    
    fh = open(fname, 'rU')
    outname = 'opcodes_%s.py' % name
    fout = open(outname, 'w') #sys.stdout
    
    print >>fout, '# autogenerated from %s, DO NOT EDIT!\n' % fname
    print >>fout, 'from hardware.cpu import CPUTrapInvalidOP\n'
    print >>fout, 'from hardware.Z80.tools import *\n'
    print >>fout, 'from tables import *\n\n'
    print >>fout, 'class Z80Mixin%s(object):' % name.upper()
    
    table = []
    
    for line in fh:
        try:
            line = line.strip()
            if not line or line.startswith('#'): continue
            
            if name.lower() in ('dd', 'ddcb'):
                line = line.replace('REGISTER', 'IX')
            elif name.lower() in ('fd', 'fdcb'):
                line = line.replace('REGISTER', 'IY')
            
            bits = [s.strip() for s in line.split('\t')]
            
            if len(bits) < 2: continue
            
            # parse line
            
            # code="OP"
            code, op = bits[0].split('=')
            code = int(code, 16)
            op = op.strip('"')
            
            # t="T1[,T2]"
            dummy, b = bits[1].split('=')
            if dummy != 't': raise ValueError('syntax error, expected "t"')
            b = b.strip('"')
            if '/' in b:
                t = [int(s) for s in b.split('/')]
            else:
                t = [int(b)]
            
            # delays
            delays = {}
            for bit in bits[2:]:
                dummy, b = bit.split('=')
                b = b.strip('"')
                if (dummy != 'rd') and (dummy != 'wr'):
                    raise ValueError('syntax error, expected "rd/wr"')
                if ',' in b:
                    delays[dummy] = [int(s) for s in b.split(',')]
                else:
                    delays[dummy] = [int(b)]
            
            table.append((code, op, convert_to_py(fout, name, code, op, t)))
        except Exception, err:
            print >>sys.stderr, line
            print >>sys.stderr, bits
            raise
    convert_to_table(fout, name, table)


def main():
    dasm_fh = open('dasmtab.py', 'w')
    
    process_ofile('opcodes_base.dat', 'base', dasm_fh)
    process_ofile('opcodes_cb.dat', 'cb', dasm_fh)
    process_ofile('opcodes_ed.dat', 'ed', dasm_fh)
    process_ofile('opcodes_ddfd.dat', 'dd', dasm_fh)
    process_ofile('opcodes_ddfd.dat', 'fd', dasm_fh)
    process_ofile('opcodes_ddfdcb.dat', 'ddcb', dasm_fh)
    process_ofile('opcodes_ddfdcb.dat', 'fdcb', dasm_fh)
    
    dasm_fh.close()

if __name__ == '__main__':
    main()